#!/usr/bin/env python3
# Copyright (C) 2025 PhoneAgent Contributors
# Licensed under AGPL-3.0

"""
API Routes - RESTful API è·¯ç”±å®šä¹‰

åŒ…å«ï¼š
- è®¾å¤‡ç®¡ç† API
- ä»»åŠ¡ç®¡ç† API
- è¯­éŸ³è¯†åˆ« API
- WebSocket å®æ—¶é€šä¿¡
"""

import asyncio
import logging
from datetime import datetime
from typing import Any, Dict, List, Optional

from fastapi import APIRouter, HTTPException, Query, WebSocket, WebSocketDisconnect
from fastapi.responses import FileResponse
from pydantic import BaseModel, Field

from server.api.anti_detection_config import router as anti_detection_router
from server.api.model_stats import router as model_stats_router
from server.api.planning import router as planning_router
from server.api.presets import router as presets_router
from server.api.schemas.task import CreateTaskRequest, ModelTestRequest, TaskResponse
from server.api.scrcpy import router as scrcpy_router
from server.api.speech_api import router as speech_router
from server.services import get_agent_service, get_device_pool
from server.services.agent_service import TaskStatus
from server.services.device_scanner import get_device_scanner
from server.websocket.connection_manager import get_connection_manager

logger = logging.getLogger(__name__)

router = APIRouter()


# æ³¨å†Œå­è·¯ç”±ï¼ˆå¸¦æ ‡ç­¾åˆ†ç±»ï¼‰

# æ³¨å†Œå­è·¯ç”±ï¼ˆå¸¦æ ‡ç­¾åˆ†ç±»ï¼‰
# æŒ‰ç…§åŠŸèƒ½æ¨¡å—åˆ†ç±»ï¼Œæ–¹ä¾¿APIæ–‡æ¡£æŸ¥çœ‹å’Œç»´æŠ¤
router.include_router(speech_router, prefix="/speech", tags=["Speech"])
router.include_router(scrcpy_router, prefix="", tags=["Streaming"])
router.include_router(planning_router, prefix="", tags=["Planning"])
router.include_router(presets_router, prefix="", tags=["Presets"])
router.include_router(model_stats_router, prefix="", tags=["Stats"])
router.include_router(anti_detection_router, prefix="", tags=["Anti-Detection"])


# ============================================
# ç«¯å£ç®¡ç† API
# ============================================


@router.get("/ports/status", summary="æŸ¥è¯¢æ‰€æœ‰ç«¯å£åˆ†é…çŠ¶æ€", tags=["ğŸ”Œ ç«¯å£ç®¡ç†"])
async def get_port_allocations():
    """è·å–æ‰€æœ‰ç«¯å£çš„åˆ†é…çŠ¶æ€"""
    from server.services.port_manager import get_port_manager

    port_manager = get_port_manager()
    allocations = await port_manager.list_allocations()

    return {"allocations": allocations, "count": len(allocations)}


@router.get("/ports/{port}/status", summary="æŸ¥è¯¢æŒ‡å®šç«¯å£çŠ¶æ€", tags=["ğŸ”Œ ç«¯å£ç®¡ç†"])
async def get_port_status(port: int):
    """æŸ¥è¯¢æŒ‡å®šç«¯å£æ˜¯å¦è¢«å ç”¨"""
    from server.services.port_manager import get_port_manager

    port_manager = get_port_manager()
    status = await port_manager.get_port_status(port)

    if status:
        return {
            "port": port,
            "occupied": True,
            "device_id": status["device_id"],
            "device_name": status["device_name"],
            "allocated_at": status["allocated_at"].isoformat(),
        }
    else:
        return {"port": port, "occupied": False}


@router.get("/ports/available", summary="æŸ¥æ‰¾å¯ç”¨ç«¯å£", tags=["ğŸ”Œ ç«¯å£ç®¡ç†"])
async def find_available_port(start: int = 6100, end: int = 6199):
    """æŸ¥æ‰¾å¯ç”¨ç«¯å£"""
    from server.services.port_manager import get_port_manager

    port_manager = get_port_manager()
    available_port = await port_manager.find_available_port(start, end)

    if available_port:
        return {"available": True, "port": available_port}
    else:
        return {"available": False, "message": f"No available ports in range {start}-{end}"}


# ============================================
# Pydantic Models (è¯·æ±‚/å“åº”æ¨¡å‹)
# ============================================
# æ³¨æ„ï¼šCreateTaskRequest å’Œ TaskResponse å·²ä» server.api.schemas.task å¯¼å…¥


class DeviceResponse(BaseModel):
    """è®¾å¤‡å“åº”"""

    device_id: str
    device_name: str
    frp_port: int
    adb_address: str
    status: str
    frp_connected: bool
    ws_connected: bool
    current_task: Optional[str]
    model: str
    android_version: str
    screen_resolution: str
    battery: int
    total_tasks: int
    success_tasks: int
    failed_tasks: int
    success_rate: float
    registered_at: str
    last_active: str


class StatsResponse(BaseModel):
    """ç»Ÿè®¡ä¿¡æ¯å“åº”"""

    device_stats: Dict[str, Any]
    task_stats: Dict[str, Any]


# ============================================
# è®¾å¤‡ç®¡ç† API
# ============================================


async def get_websocket_device_status():
    """
    ä»WebSocketæœåŠ¡å™¨æŸ¥è¯¢è®¾å¤‡è¿æ¥çŠ¶æ€ï¼ˆå¼‚æ­¥ç‰ˆæœ¬ï¼‰

    è¿”å›ä¸¤ç§æ˜ å°„ï¼š
    - ws_by_id: device_id -> ws_connectedï¼ˆä¸»è¦åŒ¹é…æ–¹å¼ï¼Œæ ¼å¼ï¼šdevice_{frp_port}ï¼‰
    - ws_by_port: frp_port -> ws_connectedï¼ˆå¤‡ç”¨åŒ¹é…æ–¹å¼ï¼‰
    """
    import os

    # ä»ç¯å¢ƒå˜é‡è·å–WebSocketæœåŠ¡å™¨åœ°å€ï¼Œé»˜è®¤ä¸ºæœ¬åœ°
    ws_host = os.getenv("WEBSOCKET_HOST", "127.0.0.1")
    ws_port = os.getenv("WEBSOCKET_PORT", "9999")

    # å°è¯•å¤šä¸ªå¯èƒ½çš„åœ°å€ï¼ˆåŒ…æ‹¬å¤–ç½‘IPï¼Œè§£å†³Docker/å®¹å™¨ç¯å¢ƒé—®é¢˜ï¼‰
    # ä¼˜å…ˆçº§ï¼šç¯å¢ƒå˜é‡é…ç½® > æœ¬åœ°å›ç¯ > å¤–ç½‘IPï¼ˆå…œåº•ï¼‰
    websocket_urls = [
        f"http://{ws_host}:{ws_port}/devices",
        "http://127.0.0.1:9999/devices",
        "http://localhost:9999/devices",
        # å…œåº•ï¼šå°è¯•é€šè¿‡Dockerç½‘å…³æˆ–å¤–ç½‘IPè®¿é—®
        "http://host.docker.internal:9999/devices",  # Docker Desktop
        "http://172.17.0.1:9999/devices",  # Dockeré»˜è®¤ç½‘å…³
    ]

    errors = []
    for url in websocket_urls:
        try:
            import httpx

            async with httpx.AsyncClient(timeout=1.0) as client:  # é™ä½è¶…æ—¶åˆ°1ç§’
                response = await client.get(url)
            if response.status_code == 200:
                data = response.json()
                # è¿”å›è®¾å¤‡çŠ¶æ€æ˜ å°„
                ws_status = {
                    "by_id": {},  # device_id -> ws_connected
                    "by_port": {},  # frp_port -> ws_connected
                }
                for device in data.get("devices", []):
                    device_id = device.get("device_id")
                    frp_port = device.get("frp_port")
                    ws_connected = device.get("ws_connected", False)

                    # æŒ‰ device_id æ˜ å°„ï¼ˆä¸»è¦æ–¹å¼ï¼‰
                    if device_id:
                        ws_status["by_id"][device_id] = ws_connected

                    # æŒ‰ frp_port æ˜ å°„ï¼ˆå¤‡ç”¨æ–¹å¼ï¼‰
                    if frp_port:
                        ws_status["by_port"][frp_port] = ws_connected

                logger.info(f"ä»WebSocketæœåŠ¡å™¨({url})è·å–åˆ°è®¾å¤‡çŠ¶æ€: {ws_status}")
                return ws_status
            else:
                errors.append(f"{url}: HTTP {response.status_code}")
        except Exception as e:
            errors.append(f"{url}: {type(e).__name__}: {e}")

    logger.error(f"æ‰€æœ‰WebSocketæœåŠ¡å™¨åœ°å€éƒ½æ— æ³•è¿æ¥: {errors}")
    return {"by_id": {}, "by_port": {}}


@router.get("/devices/scanned", tags=["ğŸ“± è®¾å¤‡ç®¡ç†"])
async def list_scanned_devices():
    """
    è·å–æ‰«æåˆ°çš„è®¾å¤‡åˆ—è¡¨ï¼ˆä¼˜åŒ–ç‰ˆ - æ·»åŠ ç¼“å­˜ï¼‰

    æœåŠ¡ç«¯ä¸»åŠ¨æ‰«æFRPç«¯å£å‘ç°çš„è®¾å¤‡
    ç»“åˆWebSocketè¿æ¥çŠ¶æ€
    """
    scanner = get_device_scanner()

    # ä¼˜åŒ–ï¼šç›´æ¥è¿”å›ç¼“å­˜çš„è®¾å¤‡åˆ—è¡¨ï¼Œä¸è§¦å‘æ–°æ‰«æ
    online_devices = scanner.get_online_devices()

    # ä»WebSocketæœåŠ¡å™¨æŸ¥è¯¢è®¾å¤‡çŠ¶æ€ï¼ˆå¼‚æ­¥ï¼‰
    ws_device_status = await get_websocket_device_status()

    devices = []
    for device_id, device in online_devices.items():
        # æŸ¥è¯¢WebSocketè¿æ¥çŠ¶æ€ï¼ˆä¼˜å…ˆæŒ‰device_idåŒ¹é…ï¼Œå…¶æ¬¡æŒ‰frp_portåŒ¹é…ï¼‰
        ws_connected = ws_device_status["by_id"].get(
            device_id, False
        ) or ws_device_status[  # æŒ‰device_idåŒ¹é…ï¼ˆdevice_{frp_port}æ ¼å¼ï¼‰
            "by_port"
        ].get(
            device.frp_port, False
        )  # æŒ‰frp_portåŒ¹é…ï¼ˆå¤‡ç”¨ï¼‰

        # åªåŒ…å«æˆåŠŸè·å–çš„å­—æ®µï¼ŒNoneå€¼ä¸è¿”å›
        device_data = {
            "device_id": device.device_id,
            "device_name": device.device_name,  # ä½¿ç”¨è®¾å¤‡åç§°
            "status": "online" if device.is_online else "offline",
            "frp_port": device.frp_port,
            "adb_address": device.adb_address,
            # è¿æ¥çŠ¶æ€
            "frp_connected": True,  # èƒ½æ‰«æåˆ°è¯´æ˜FRPå·²è¿æ¥
            "ws_connected": ws_connected,  # ä»WebSocketç®¡ç†å™¨æŸ¥è¯¢å®é™…è¿æ¥çŠ¶æ€
            # ä»»åŠ¡ç»Ÿè®¡ï¼ˆV2æš‚ä¸æ”¯æŒï¼‰
            "current_task": None,
            "total_tasks": 0,
            "success_tasks": 0,
            "failed_tasks": 0,
            "success_rate": 0.0,
            # æ—¶é—´å­—æ®µï¼ˆå…¼å®¹V1å‘½åï¼‰
            "registered_at": device.discovered_at.isoformat(),
            "last_active": device.last_seen.isoformat(),
            "discovered_at": device.discovered_at.isoformat(),
            "last_seen": device.last_seen.isoformat(),
            "method": "port_scanning",  # æ ‡è¯†è¿™æ˜¯æ‰«æå‘ç°çš„
        }

        # åªæ·»åŠ æˆåŠŸè·å–çš„å­—æ®µï¼ˆä¸ä¸ºNoneï¼‰
        if device.model:
            device_data["model"] = device.model
        if device.android_version:
            device_data["android_version"] = device.android_version
        if device.screen_resolution:
            device_data["screen_resolution"] = device.screen_resolution
        if device.battery is not None:
            device_data["battery"] = device.battery
        if device.memory_total:
            device_data["memory_total"] = device.memory_total
        if device.memory_available:
            device_data["memory_available"] = device.memory_available
        if device.storage_total:
            device_data["storage_total"] = device.storage_total
        if device.storage_available:
            device_data["storage_available"] = device.storage_available

        devices.append(device_data)

    return {"devices": devices, "count": len(devices), "method": "active_scanning"}


# åºŸå¼ƒæ¥å£å·²åˆ é™¤: GET /devices -> è¯·ä½¿ç”¨ GET /devices/scanned


@router.get("/devices/{device_id}", tags=["ğŸ“± è®¾å¤‡ç®¡ç†"])
async def get_device(device_id: str):
    """è·å–è®¾å¤‡è¯¦æƒ…ï¼ˆä»V2æ‰«æå™¨ï¼‰"""
    from server.services.device_scanner import get_device_scanner

    scanner = get_device_scanner()
    scanned_devices = scanner.get_scanned_devices()

    if device_id not in scanned_devices:
        raise HTTPException(404, f"Device not found: {device_id}")

    device = scanned_devices[device_id]

    # è¿”å›å®Œæ•´è®¾å¤‡ä¿¡æ¯
    return {
        "device_id": device.device_id,
        "device_name": device.device_name,  # ä½¿ç”¨device_nameè€Œä¸æ˜¯device_id
        "status": "online" if device.is_online else "offline",
        "frp_port": device.frp_port,
        "adb_address": device.adb_address,
        "model": device.model,
        "android_version": device.android_version,
        "screen_resolution": device.screen_resolution,
        "battery": device.battery,
        "memory_total": device.memory_total,
        "memory_available": device.memory_available,
        "storage_total": device.storage_total,
        "storage_available": device.storage_available,
        "frp_connected": True,
        "ws_connected": False,
        "discovered_at": device.discovered_at.isoformat(),
        "last_seen": device.last_seen.isoformat(),
        "method": "port_scanning",
    }


class RenameDeviceRequest(BaseModel):
    """è®¾å¤‡é‡å‘½åè¯·æ±‚"""

    device_name: str = Field(..., min_length=1, max_length=50, description="æ–°è®¾å¤‡åç§°")


@router.patch("/devices/{device_id}/name", summary="é‡å‘½åè®¾å¤‡", tags=["ğŸ“± è®¾å¤‡ç®¡ç†"])
async def rename_device(device_id: str, request: RenameDeviceRequest):
    """
    æ›´æ–°è®¾å¤‡åç§°

    ç”¨æˆ·å¯ä»¥ä¸ºè®¾å¤‡è®¾ç½®è‡ªå®šä¹‰åç§°ï¼Œä¾¿äºè¯†åˆ«
    """
    from server.services.device_scanner import get_device_scanner

    device_scanner = get_device_scanner()
    success = await device_scanner.update_device_name(device_id, request.device_name)

    if not success:
        raise HTTPException(404, f"Device not found: {device_id}")

    return {
        "message": "Device renamed successfully",
        "device_id": device_id,
        "new_name": request.device_name,
    }


# ============================================
# ä»»åŠ¡ç®¡ç† API
# ============================================


@router.post("/tasks", response_model=TaskResponse, tags=["ğŸ“‹ ä»»åŠ¡ç®¡ç†"])
async def create_task(request: CreateTaskRequest):
    """
    åˆ›å»ºä»»åŠ¡

    æ”¯æŒä¸¤ç§æ¨¡å¼ï¼š
    1. æŒ‡å®šè®¾å¤‡IDï¼ˆdevice_idï¼‰
    2. è‡ªåŠ¨åˆ†é…ï¼ˆä»è®¾å¤‡æ± é€‰æ‹©å¯ç”¨è®¾å¤‡ï¼‰
    """
    agent_service = get_agent_service()

    # å¯¼å…¥é…ç½®ï¼ˆåœ¨ä½¿ç”¨å‰å¯¼å…¥ï¼‰
    from server.config import Config

    config = Config()

    # æ„å»ºæ¨¡å‹é…ç½®
    # Warning: å·²åºŸå¼ƒXML/æ··åˆå†…æ ¸ï¼Œç»Ÿä¸€ä½¿ç”¨Visionå†…æ ¸
    # å¦‚æœç”¨æˆ·æœªæ˜ç¡®æŒ‡å®šæ¨¡å‹ï¼Œè®©æ™ºèƒ½é€‰æ‹©å™¨å†³å®š
    should_use_selector = not request.ai_model or request.ai_model == "autoglm-phone"

    model_config = {
        "provider": request.ai_provider,
        "max_steps": request.max_steps or config.MAX_TASK_STEPS,  # ä½¿ç”¨ç¯å¢ƒå˜é‡é»˜è®¤å€¼
        "max_history_images": (
            request.max_history_images
            if request.max_history_images is not None
            else config.MAX_HISTORY_IMAGES
        ),
        "kernel_mode": "vision",  # å¼ºåˆ¶ä½¿ç”¨visionå†…æ ¸
    }
    if request.ai_base_url:
        model_config["base_url"] = request.ai_base_url

    # åªæœ‰ç”¨æˆ·æ˜ç¡®æŒ‡å®šéé»˜è®¤æ¨¡å‹æ—¶ï¼Œæ‰ä¼ é€’ model_name
    if request.ai_model and request.ai_model != "autoglm-phone":
        model_config["model_name"] = request.ai_model
    # å¦åˆ™è®©æ™ºèƒ½é€‰æ‹©å™¨åœ¨ agent_service._run_agent ä¸­å†³å®šï¼ˆä¼šé€‰æ‹©glm-4.6v-flashï¼‰

    # ä½¿ç”¨ç”¨æˆ·æä¾›çš„API Keyï¼Œå¦‚æœæ²¡æœ‰åˆ™ä»ç¯å¢ƒå˜é‡åŠ è½½
    if request.ai_api_key:
        model_config["api_key"] = request.ai_api_key
    else:
        # ä» .env æ–‡ä»¶è‡ªåŠ¨åŠ è½½ API Keyï¼ˆæ”¯æŒå¤šå¹³å°ï¼šzhipu, openai, gemini, qwen, localï¼‰
        from server.utils.model_config_helper import get_model_config_from_env

        env_config = get_model_config_from_env("vision")

        if env_config["api_key"] and env_config["api_key"] != "EMPTY":
            model_config["api_key"] = env_config["api_key"]
            # å¦‚æœç”¨æˆ·æ²¡æœ‰æŒ‡å®šæ¨¡å‹ï¼Œä¹Ÿä½¿ç”¨ç¯å¢ƒé…ç½®
            if should_use_selector and "model_name" not in model_config:
                model_config["model_name"] = env_config["model_name"]
            if "base_url" not in model_config:
                model_config["base_url"] = env_config["base_url"]
        elif config.MODEL_PROVIDER == "local":
            # æœ¬åœ°æ¨¡å‹ä¸éœ€è¦ API Key
            model_config["api_key"] = "EMPTY"
            model_config["base_url"] = env_config["base_url"]
            if "model_name" not in model_config:
                model_config["model_name"] = env_config["model_name"]
        else:
            raise HTTPException(
                400,
                "æœªé…ç½®API Keyï¼Œè¯·åœ¨.envä¸­è®¾ç½®ï¼š\n"
                "- æ™ºè°±AI: ZHIPU_API_KEY=xxx\n"
                "- OpenAI/å…¶ä»–: CUSTOM_API_KEY=xxx\n"
                "- æœ¬åœ°æ¨¡å‹: MODEL_PROVIDER=local",
            )

    # å¤„ç†æç¤ºè¯å¡ç‰‡ï¼šæ‹¼æ¥åˆ°æŒ‡ä»¤ä¸­
    enhanced_instruction = request.instruction
    if request.prompt_card_ids and len(request.prompt_card_ids) > 0:
        from server.api.presets import prompt_cards_store

        all_cards = prompt_cards_store.load()
        selected_cards = [card for card in all_cards if card.id in request.prompt_card_ids]

        if selected_cards:
            prompt_cards_content = "\n\n===== ä»»åŠ¡ä¼˜åŒ–æç¤ºè¯ =====\n"
            for card in selected_cards:
                prompt_cards_content += f"\nã€{card.title}ã€‘\n{card.content}\n"
            prompt_cards_content += "\n===== æç¤ºè¯ç»“æŸ =====\n"
            enhanced_instruction = f"{request.instruction}{prompt_cards_content}"

    # åˆ›å»ºä»»åŠ¡
    task_id = await agent_service.create_task(
        instruction=enhanced_instruction,  # ä½¿ç”¨å¢å¼ºåçš„æŒ‡ä»¤
        model_config=model_config,
        device_id=request.device_id,
    )

    # æ‰§è¡Œä»»åŠ¡
    device_pool = get_device_pool()
    success = await agent_service.execute_task(task_id, device_pool)

    if not success:
        raise HTTPException(400, "Failed to start task execution")

    # è·å–ä»»åŠ¡ä¿¡æ¯
    task = agent_service.get_task(task_id)
    if not task:
        raise HTTPException(500, "Task created but not found")

    return TaskResponse(
        task_id=task.task_id,
        instruction=task.instruction,
        device_id=task.device_id,
        status=task.status.value,
        created_at=task.created_at.isoformat(),
        started_at=task.started_at.isoformat() if task.started_at else None,
        completed_at=task.completed_at.isoformat() if task.completed_at else None,
        duration=task.duration,
        result=task.result,
        error=task.error,
        steps=task.steps,
    )


@router.post("/model/test", summary="æµ‹è¯•AIæ¨¡å‹è¿æ¥", tags=["ğŸ¤– æ¨¡å‹ç®¡ç†"])
async def test_model_connection(request: ModelTestRequest):
    """
    æµ‹è¯•AIæ¨¡å‹è¿æ¥
    
    éªŒè¯æä¾›çš„æ¨¡å‹é…ç½®æ˜¯å¦æœ‰æ•ˆï¼Œå°è¯•ç”Ÿæˆç®€å•çš„å›å¤
    """
    from phone_agent.model.client import ModelClient, ModelConfig
    from server.config import Config
    from server.utils.model_config_helper import get_model_config_from_env

    config = Config()

    # å‡†å¤‡æ¨¡å‹é…ç½®
    base_url = request.base_url
    api_key = request.api_key
    model_name = request.model_name

    # å¦‚æœæœªæä¾›ï¼Œå°è¯•ä»ç¯å¢ƒå˜é‡åŠ è½½
    # ç±»ä¼¼äº create_task ä¸­çš„é€»è¾‘
    if not api_key:
        env_config = get_model_config_from_env("vision")

        # è¿™é‡Œçš„é€»è¾‘éœ€è¦æ ¹æ®providerè°ƒæ•´ï¼Œä½†ä¸ºç®€å•èµ·è§ï¼Œæˆ‘ä»¬ä¼˜å…ˆä½¿ç”¨ç”¨æˆ·æä¾›çš„
        # å¦‚æœæ˜¯ default/zhipu ä¸”ä¸ºç©ºï¼Œå°è¯•åŠ è½½ç¯å¢ƒé…ç½®
        if request.provider in ["default", "zhipu"]:
            if not base_url:
                base_url = env_config.get("base_url")
            if not model_name:
                model_name = env_config.get("model_name")
            if not api_key and env_config.get("api_key") != "EMPTY":
                api_key = env_config.get("api_key")

        # æœ¬åœ°æ¨¡å‹ç‰¹æ®Šå¤„ç†
        if request.provider == "local" or config.MODEL_PROVIDER == "local":
            if not api_key:
                api_key = "EMPTY"
            if not base_url:
                base_url = request.base_url or env_config.get("base_url", "http://localhost:8000/v1")

    # æ„å»ºå®Œæ•´é…ç½®
    # å¦‚æœ model_name ä¾ç„¶ä¸ºç©ºï¼Œä½¿ç”¨é»˜è®¤å€¼
    if not model_name and request.provider == "zhipu":
        model_name = "glm-4-flash"
    elif not model_name and request.provider == "local":
        model_name = "vicuna-7b-v1.5"
    elif not model_name:
        model_name = "autoglm-phone"

    model_config = ModelConfig(
        base_url=base_url or "https://open.bigmodel.cn/api/paas/v4/", # å…œåº•é»˜è®¤å€¼
        api_key=api_key or "EMPTY",
        model_name=model_name,
        max_tokens=20, # æµ‹è¯•åªéœ€è¦ç”Ÿæˆå°‘é‡token
        temperature=0.1,
    )

    try:
        # åˆå§‹åŒ–å®¢æˆ·ç«¯
        client = ModelClient(model_config)

        # å‘é€ç®€å•æµ‹è¯•è¯·æ±‚
        messages = [{"role": "user", "content": "Hi"}]
        start_time = datetime.now()
        response = client.request(messages)
        duration = (datetime.now() - start_time).total_seconds()

        return {
            "success": True,
            "message": "Connection successful",
            "latency_ms": int(duration * 1000),
            "response": response.raw_content[:200] + "..." if len(response.raw_content) > 200 else response.raw_content,
            "model_used": model_config.model_name
        }
    except Exception as e:
        logger.error(f"Model connection test failed: {e}")
        return {
            "success": False,
            "message": str(e),
            "error_type": type(e).__name__
        }


@router.get("/tasks", response_model=List[TaskResponse], tags=["ğŸ“‹ ä»»åŠ¡ç®¡ç†"])
async def list_tasks(status: Optional[str] = None, limit: int = 100, offset: int = 0):
    """
    è·å–ä»»åŠ¡åˆ—è¡¨ï¼ˆä¼˜åŒ–ç‰ˆ - ä½¿ç”¨å¼‚æ­¥æŸ¥è¯¢ï¼‰

    Args:
        status: ç­›é€‰çŠ¶æ€ (pending, running, completed, failed, cancelled)
        limit: è¿”å›æ•°é‡
        offset: åç§»é‡
    """
    agent_service = get_agent_service()

    # ç­›é€‰çŠ¶æ€
    filter_status = None
    if status:
        try:
            filter_status = TaskStatus(status)
        except ValueError:
            raise HTTPException(400, f"Invalid status: {status}")

    # ä½¿ç”¨å¼‚æ­¥ç‰ˆæœ¬é¿å…é˜»å¡
    tasks = await agent_service.list_tasks_async(status=filter_status, limit=limit, offset=offset)

    return [
        TaskResponse(
            task_id=t.task_id,
            instruction=t.instruction,
            device_id=t.device_id,
            status=t.status.value,
            created_at=t.created_at.isoformat(),
            started_at=t.started_at.isoformat() if t.started_at else None,
            completed_at=t.completed_at.isoformat() if t.completed_at else None,
            duration=t.duration,
            result=t.result,
            error=t.error,
            steps=t.steps,  # ä¿®å¤ï¼šè¿”å›å®Œæ•´æ­¥éª¤åˆ—è¡¨
            total_tokens=t.total_tokens,
            total_prompt_tokens=t.total_prompt_tokens,
            total_completion_tokens=t.total_completion_tokens,
        )
        for t in tasks
    ]


@router.get("/tasks/{task_id}", response_model=TaskResponse, tags=["ğŸ“‹ ä»»åŠ¡ç®¡ç†"])
async def get_task(task_id: str):
    """è·å–ä»»åŠ¡è¯¦æƒ…ï¼ˆä¼˜åŒ–ç‰ˆ - ä½¿ç”¨å¼‚æ­¥æŸ¥è¯¢ï¼‰"""
    agent_service = get_agent_service()
    # ä½¿ç”¨å¼‚æ­¥ç‰ˆæœ¬é¿å…é˜»å¡
    task = await agent_service.get_task_async(task_id)

    if not task:
        raise HTTPException(404, f"Task not found: {task_id}")

    return TaskResponse(
        task_id=task.task_id,
        instruction=task.instruction,
        device_id=task.device_id,
        status=task.status.value,
        created_at=task.created_at.isoformat(),
        started_at=task.started_at.isoformat() if task.started_at else None,
        completed_at=task.completed_at.isoformat() if task.completed_at else None,
        duration=task.duration,
        result=task.result,
        error=task.error,
        steps=task.steps,  # ä¿®å¤ï¼šè¿”å›å®Œæ•´æ­¥éª¤åˆ—è¡¨è€Œä¸æ˜¯æ­¥éª¤æ•°é‡
        total_tokens=task.total_tokens,
        total_prompt_tokens=task.total_prompt_tokens,
        total_completion_tokens=task.total_completion_tokens,
    )


@router.get("/tasks/{task_id}/steps", tags=["ğŸ“‹ ä»»åŠ¡ç®¡ç†"])
async def get_task_steps(task_id: str):
    """è·å–ä»»åŠ¡çš„è¯¦ç»†æ­¥éª¤ä¿¡æ¯"""
    agent_service = get_agent_service()
    task = agent_service.get_task(task_id)

    if not task:
        raise HTTPException(404, f"Task not found: {task_id}")

    return {
        "task_id": task.task_id,
        "instruction": task.instruction,
        "status": task.status.value,
        "current_step": task.current_step,
        "total_steps": len(task.steps),
        "steps": task.steps,  # è¿”å›å®Œæ•´çš„æ­¥éª¤åˆ—è¡¨ï¼ˆåŒ…å«tokenå’Œè€—æ—¶ï¼‰
        "total_tokens": task.total_tokens,
        "total_prompt_tokens": task.total_prompt_tokens,
        "total_completion_tokens": task.total_completion_tokens,
    }


@router.get("/tasks/{task_id}/context", tags=["ğŸ“‹ ä»»åŠ¡ç®¡ç†"])
async def get_task_context(task_id: str):
    """
    è·å–ä»»åŠ¡çš„ LLM ä¸Šä¸‹æ–‡ï¼ˆç”¨äºè°ƒè¯• Agent æ€ç»´é“¾ï¼‰

    æ³¨æ„ï¼š
    1. ä»…èƒ½è·å–å†…å­˜ä¸­è¿è¡Œçš„ä»»åŠ¡ï¼ˆæˆ–åˆšå®Œæˆæœªè¢«æ¸…ç†çš„ä»»åŠ¡ï¼‰
    2. ä¸Šä¸‹æ–‡åŒ…å«å®Œæ•´çš„ç³»ç»Ÿæç¤ºè¯ã€ç”¨æˆ·è¾“å…¥ï¼ˆå«æˆªå›¾Base64ï¼‰å’Œæ¨¡å‹å“åº”
    """
    agent_service = get_agent_service()
    context = agent_service.get_task_context(task_id)

    if context is None:
        # å¦‚æœæ˜¯å·²å®Œæˆçš„ä»»åŠ¡ï¼Œä¸Šä¸‹æ–‡å¯èƒ½å·²è¢«æ¸…ç†
        raise HTTPException(
            404,
            "Context not found. The task might be completed and cleaned up from memory, "
            "or it was never started.",
        )

    # è¿‡æ»¤æ‰è¿‡å¤§çš„ Base64 å›¾ç‰‡æ•°æ®ï¼Œé¿å…å“åº”è¿‡å¤§
    # å‰ç«¯åªéœ€è¦çŸ¥é“è¿™é‡Œæœ‰å›¾ç‰‡å³å¯
    filtered_context = []
    for msg in context:
        msg_copy = msg.copy()
        # é€’å½’æŸ¥æ‰¾ image_url å¹¶æ›¿æ¢ base64
        if "content" in msg_copy and isinstance(msg_copy["content"], list):
            new_content = []
            for item in msg_copy["content"]:
                item_copy = item.copy()
                if item_copy.get("type") == "image_url":
                    url = item_copy.get("image_url", {}).get("url", "")
                    if url.startswith("data:image"):
                        # ä¿ç•™å‰ç¼€ä»¥ä¾¿è¯†åˆ«ï¼Œä½†æˆªæ–­å†…å®¹
                        item_copy["image_url"]["url"] = f"{url[:30]}...[BASE64_IMAGE_HIDDEN]"
                new_content.append(item_copy)
            msg_copy["content"] = new_content
        filtered_context.append(msg_copy)

    return {"task_id": task_id, "context": filtered_context}


class InjectCommentRequest(BaseModel):
    """ç”¨æˆ·è¯„è®ºæ³¨å…¥è¯·æ±‚"""

    comment: str


@router.post("/tasks/{task_id}/inject", tags=["ğŸ“‹ ä»»åŠ¡ç®¡ç†"])
async def inject_comment(task_id: str, request: InjectCommentRequest):
    """
    å‘è¿è¡Œä¸­çš„ä»»åŠ¡æ³¨å…¥ç”¨æˆ·è¯„è®º

    æ³¨å…¥çš„è¯„è®ºä¼šä½œä¸º[User Intervention]æ·»åŠ åˆ°LLMä¸Šä¸‹æ–‡ä¸­ï¼Œ
    åœ¨ä¸‹ä¸€æ­¥æ‰§è¡Œæ—¶è¢«æ¨¡å‹çœ‹åˆ°ã€‚

    ä½¿ç”¨åœºæ™¯ï¼š
    - çº æ­£Agentçš„é”™è¯¯åˆ¤æ–­
    - æä¾›é¢å¤–çš„ä¸Šä¸‹æ–‡ä¿¡æ¯
    - å¼•å¯¼Agentæ‰§è¡Œç‰¹å®šæ“ä½œ

    æ³¨æ„ï¼š
    - ä»…å¯¹è¿è¡Œä¸­çš„ä»»åŠ¡æœ‰æ•ˆ
    - è¯„è®ºä¼šåœ¨ä¸‹ä¸€ä¸ªstepç”Ÿæ•ˆ
    """
    agent_service = get_agent_service()
    success = agent_service.inject_comment(task_id, request.comment)

    if not success:
        raise HTTPException(
            400,
            f"Failed to inject comment. Task {task_id} might not be running "
            "or already completed.",
        )

    return {
        "success": True,
        "task_id": task_id,
        "message": "Comment injected successfully. It will be visible to the model in the next step.",
    }


@router.post("/tasks/{task_id}/cancel", tags=["ğŸ“‹ ä»»åŠ¡ç®¡ç†"])
async def cancel_task(task_id: str):
    """å–æ¶ˆæ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡"""
    agent_service = get_agent_service()
    success = await agent_service.cancel_task(task_id)

    if not success:
        raise HTTPException(400, f"Failed to cancel task: {task_id}")

    return {"message": "Task cancelled", "task_id": task_id}


@router.delete("/tasks/{task_id}", tags=["ğŸ“‹ ä»»åŠ¡ç®¡ç†"])
async def delete_task(task_id: str):
    """åˆ é™¤ä»»åŠ¡è®°å½•ï¼ˆä»…èƒ½åˆ é™¤å·²å®Œæˆ/å¤±è´¥çš„ä»»åŠ¡ï¼‰"""
    from server.database import get_db
    from server.database.crud import delete_task as db_delete_task
    from server.database.crud import get_task as db_get_task

    db = next(get_db())

    # æ£€æŸ¥ä»»åŠ¡æ˜¯å¦å­˜åœ¨
    db_task = db_get_task(db, task_id)
    if not db_task:
        raise HTTPException(404, f"Task not found: {task_id}")

    # åªèƒ½åˆ é™¤å·²å®Œæˆæˆ–å¤±è´¥çš„ä»»åŠ¡
    if db_task.status not in ["completed", "failed", "cancelled"]:
        raise HTTPException(400, "Cannot delete running task. Please cancel it first.")

    # åˆ é™¤ä»»åŠ¡
    success = db_delete_task(db, task_id)

    if not success:
        raise HTTPException(500, f"Failed to delete task: {task_id}")

    return {"message": "Task deleted", "task_id": task_id}


@router.post("/tasks/delete-batch", tags=["ğŸ“‹ ä»»åŠ¡ç®¡ç†"])
async def delete_tasks_batch(request: dict):
    """æ‰¹é‡åˆ é™¤ä»»åŠ¡è®°å½•"""
    from server.database import get_db
    from server.database.crud import delete_tasks_batch as db_delete_tasks_batch

    task_ids = request.get("task_ids", [])
    if not task_ids:
        raise HTTPException(400, "task_ids is required")

    db = next(get_db())
    count = db_delete_tasks_batch(db, task_ids)

    return {"message": f"Deleted {count} tasks", "count": count}


# ============================================
# ç»Ÿè®¡ä¿¡æ¯ API
# ============================================


@router.get("/stats", response_model=StatsResponse, tags=["ğŸ“Š ç»Ÿè®¡ä¿¡æ¯"])
async def get_stats():
    """è·å–æ•´ä½“ç»Ÿè®¡ä¿¡æ¯"""
    device_pool = get_device_pool()
    agent_service = get_agent_service()

    return StatsResponse(device_stats=device_pool.get_stats(), task_stats=agent_service.get_stats())


# ============================================
# è¯­éŸ³è¯†åˆ« API - å·²è¿ç§»åˆ° speech_api.py
# ============================================
#
# è¯­éŸ³ç›¸å…³æ¥å£å·²è¿ç§»åˆ°ä¸“é—¨çš„ speech_api.py æ–‡ä»¶ä¸­ï¼š
# - POST /api/v1/speech/stt  - è¯­éŸ³è½¬æ–‡å­—
# - POST /api/v1/speech/tts  - æ–‡å­—è½¬è¯­éŸ³
# - GET  /api/v1/speech/health - å¥åº·æ£€æŸ¥
#


# ============================================
# WebSocket å®æ—¶é€šä¿¡
# ============================================


manager = get_connection_manager()


@router.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    """
    WebSocketç«¯ç‚¹ - å®æ—¶ä»»åŠ¡çŠ¶æ€æ¨é€

    æ¶ˆæ¯æ ¼å¼:
    {
        "type": "task_update" | "device_update" | "heartbeat",
        "data": {...}
    }
    """
    await manager.connect(websocket)

    try:
        while True:
            # æ¥æ”¶å®¢æˆ·ç«¯æ¶ˆæ¯
            data = await websocket.receive_json()

            # å¤„ç†å¿ƒè·³
            if data.get("type") == "ping":
                await websocket.send_json({"type": "pong"})

            # å¤„ç†è®¢é˜…è¯·æ±‚
            elif data.get("type") == "subscribe":
                # å‘é€å½“å‰çŠ¶æ€
                device_pool = get_device_pool()
                agent_service = get_agent_service()

                await websocket.send_json(
                    {
                        "type": "initial_state",
                        "data": {
                            "devices": len(device_pool.devices),
                            "tasks": len(agent_service.running_tasks),
                        },
                    }
                )

            # ç­‰å¾…ä¸€æ®µæ—¶é—´å†æ£€æŸ¥çŠ¶æ€ï¼ˆé¿å…è¿‡äºé¢‘ç¹ï¼‰
            await asyncio.sleep(1)

    except WebSocketDisconnect:
        manager.disconnect(websocket)
    except Exception as e:
        logger.error(f"WebSocket error: {e}", exc_info=True)
        manager.disconnect(websocket)


# ============================================
# åå°ä»»åŠ¡ï¼šå®šæœŸæ¨é€çŠ¶æ€æ›´æ–°
# ============================================


async def broadcast_status_updates():
    """å®šæœŸå¹¿æ’­çŠ¶æ€æ›´æ–°"""
    while True:
        try:
            await asyncio.sleep(5)  # æ¯5ç§’æ¨é€ä¸€æ¬¡

            device_pool = get_device_pool()
            agent_service = get_agent_service()

            # å¹¿æ’­è®¾å¤‡çŠ¶æ€
            await manager.broadcast({"type": "device_update", "data": device_pool.get_stats()})

            # å¹¿æ’­ä»»åŠ¡çŠ¶æ€
            await manager.broadcast({"type": "task_update", "data": agent_service.get_stats()})

        except Exception as e:
            logger.error(f"Broadcast error: {e}", exc_info=True)


# ============================================
# å¯åŠ¨åå°ä»»åŠ¡å·²è¿ç§»åˆ° app.py çš„ lifespan
# ============================================
#
# Warning: æ³¨æ„ï¼š@router.on_event("startup") åœ¨ FastAPI 2.0+ ä¸­å·²åºŸå¼ƒ
# æ‰€æœ‰å¯åŠ¨é€»è¾‘å·²è¿ç§»åˆ° app.py çš„ lifespan å‡½æ•°ä¸­ï¼š
# - WebSocketå¹¿æ’­å›è°ƒè®¾ç½®
# - åå°ä»»åŠ¡å¯åŠ¨
#

# ============================================
# è¯­éŸ³APIå·²è¿ç§»åˆ° speech_api.py
# ============================================
#
# è¯­éŸ³ç›¸å…³æ¥å£å·²è¿ç§»åˆ°ä¸“é—¨çš„ speech_api.py æ–‡ä»¶ä¸­ï¼š
# - POST /api/v1/speech/stt  - è¯­éŸ³è½¬æ–‡å­—
# - POST /api/v1/speech/tts  - æ–‡å­—è½¬è¯­éŸ³
# - GET  /api/v1/speech/health - å¥åº·æ£€æŸ¥
#


# ============================================
# æˆªå›¾ç®¡ç† API
# ============================================


@router.get("/screenshots/{task_id}/{filename}", tags=["ğŸ–¼ï¸ æˆªå›¾ç®¡ç†"])
async def get_screenshot(task_id: str, filename: str):
    """
    è·å–ä»»åŠ¡æ­¥éª¤æˆªå›¾

    Args:
        task_id: ä»»åŠ¡ID
        filename: æ–‡ä»¶åï¼ˆå¦‚ step_001_small.jpgï¼‰
    """
    import os

    # æ„å»ºæ–‡ä»¶è·¯å¾„
    screenshot_path = os.path.join("data", "screenshots", task_id, filename)

    # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    if not os.path.exists(screenshot_path):
        raise HTTPException(status_code=404, detail="æˆªå›¾æ–‡ä»¶ä¸å­˜åœ¨")

    # è¿”å›æ–‡ä»¶
    return FileResponse(path=screenshot_path, media_type="image/jpeg", filename=filename)


@router.get("/devices/{device_id}/screenshot", tags=["ğŸ–¼ï¸ æˆªå›¾ç®¡ç†"])
async def get_device_screenshot(device_id: str, size: str = "medium"):
    """
    è·å–è®¾å¤‡å®æ—¶æˆªå›¾

    Args:
        device_id: è®¾å¤‡ID (å¦‚ device_6100)
        size: å°ºå¯¸çº§åˆ« (ai/medium/small/thumbnail)
    """
    import asyncio
    import base64
    import os
    import tempfile

    from phone_agent.adb import get_screenshot
    from server.utils.image_utils import compress_screenshot

    try:
        # å°† device_id è½¬æ¢ä¸º ADB åœ°å€ (device_6100 -> localhost:6100)
        from server.utils import device_id_to_adb_address

        adb_address = device_id_to_adb_address(device_id)

        # è·å–æˆªå›¾
        screenshot = await asyncio.to_thread(get_screenshot, adb_address)

        if not screenshot or not screenshot.base64_data:
            raise HTTPException(status_code=500, detail="æ— æ³•è·å–è®¾å¤‡æˆªå›¾")

        # ä¿å­˜ä¸´æ—¶æˆªå›¾
        with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as tmp:
            tmp.write(base64.b64decode(screenshot.base64_data))
            tmp_path = tmp.name
            tmp.flush()  # ç¡®ä¿æ•°æ®å†™å…¥ç£ç›˜
            os.fsync(tmp.fileno())  # å¼ºåˆ¶åŒæ­¥åˆ°ç£ç›˜

        # éªŒè¯æ–‡ä»¶æ˜¯å¦å¯è¯»
        if not os.path.exists(tmp_path) or os.path.getsize(tmp_path) == 0:
            raise HTTPException(status_code=500, detail="æˆªå›¾æ–‡ä»¶ä¿å­˜å¤±è´¥")

        # å‹ç¼©æˆªå›¾
        compressed_dir = os.path.dirname(tmp_path)
        compressed_paths = await asyncio.to_thread(
            compress_screenshot, tmp_path, compressed_dir, for_ai=(size == "ai")
        )

        # è·å–æŒ‡å®šå°ºå¯¸çš„æˆªå›¾
        target_path = compressed_paths.get(size) or compressed_paths.get("medium")

        if not target_path or not os.path.exists(target_path):
            raise HTTPException(status_code=500, detail="æˆªå›¾å‹ç¼©å¤±è´¥")

        # è¯»å–æ–‡ä»¶å†…å®¹ç›´æ¥è¿”å›ï¼ˆé¿å…FileResponseå¼‚æ­¥åˆ é™¤é—®é¢˜ï¼‰
        with open(target_path, "rb") as f:
            image_data = f.read()

        # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        try:
            os.unlink(tmp_path)
            for path in compressed_paths.values():
                if path and os.path.exists(path):
                    os.unlink(path)
        except Exception:
            pass

        # è¿”å›å›¾ç‰‡æ•°æ®
        from fastapi.responses import Response

        return Response(
            content=image_data,
            media_type="image/jpeg",
            headers={
                "Content-Disposition": f'inline; filename="{device_id}_screenshot_{size}.jpg"'
            },
        )

    except Exception as e:
        logger.error(f"Get device screenshot error: {e}")
        raise HTTPException(status_code=500, detail=f"è·å–è®¾å¤‡æˆªå›¾å¤±è´¥: {str(e)}")


# ============================================
# æ—¥å¿—ç®¡ç† API
# ============================================


@router.get("/logs", tags=["ğŸ” æ—¥å¿—ç®¡ç†"])
async def get_logs(
    level: Optional[str] = Query(None, description="æ—¥å¿—çº§åˆ«è¿‡æ»¤: DEBUG, INFO, WARNING, ERROR"),
    limit: int = Query(100, ge=1, le=1000, description="è¿”å›æ¡æ•°"),
    offset: int = Query(0, ge=0, description="åç§»é‡"),
    search: Optional[str] = Query(None, description="æœç´¢å…³é”®è¯"),
):
    """
    è·å–åº”ç”¨æ—¥å¿—ï¼ˆä¼˜åŒ–ç‰ˆ - é™åˆ¶æ–‡ä»¶å¤§å°å’Œä½¿ç”¨æµå¼è¯»å–ï¼‰

    è¿”å›æ ¼å¼åŒ–çš„æ—¥å¿—åˆ—è¡¨ï¼Œæ”¯æŒè¿‡æ»¤å’Œæœç´¢
    """
    import json
    import os
    from datetime import datetime

    logs = []
    log_dir = "logs"

    # å¦‚æœæ—¥å¿—ç›®å½•ä¸å­˜åœ¨ï¼Œè¿”å›ç©ºåˆ—è¡¨
    if not os.path.exists(log_dir):
        return {"logs": [], "total": 0, "offset": offset, "limit": limit}

    # ä¼˜åŒ–ï¼šåªè¯»å–æœ€è¿‘1ä¸ªæ—¥å¿—æ–‡ä»¶ï¼Œé™åˆ¶æ–‡ä»¶å¤§å°
    log_files = sorted(
        [f for f in os.listdir(log_dir) if f.endswith(".log")],
        key=lambda x: os.path.getmtime(os.path.join(log_dir, x)),
        reverse=True,
    )[
        :1
    ]  # åªè¯»æœ€è¿‘1ä¸ªæ–‡ä»¶ï¼ˆä»3ä¸ªå‡å°‘åˆ°1ä¸ªï¼‰

    max_file_size = 10 * 1024 * 1024  # 10MB é™åˆ¶

    for log_file in log_files:
        try:
            file_path = os.path.join(log_dir, log_file)

            # ä¼˜åŒ–ï¼šæ£€æŸ¥æ–‡ä»¶å¤§å°ï¼Œè·³è¿‡è¿‡å¤§çš„æ–‡ä»¶
            if os.path.getsize(file_path) > max_file_size:
                logger.warning(f"Log file {log_file} too large, skipping")
                continue

            # ä¼˜åŒ–ï¼šåªè¯»å–æ–‡ä»¶æœ€åçš„éƒ¨åˆ†ï¼ˆå€’åºè¯»å–ï¼‰
            with open(file_path, "r", encoding="utf-8") as f:
                # è¯»å–æœ€å 5000 è¡Œ
                lines = f.readlines()[-5000:]

                for line in lines:
                    line = line.strip()
                    if not line:
                        continue

                    # å°è¯•è§£æJSONæ ¼å¼çš„æ—¥å¿—
                    try:
                        log_entry = json.loads(line)
                    except Exception:
                        # å¦‚æœä¸æ˜¯JSONï¼Œè§£ææ–‡æœ¬æ ¼å¼
                        # æ ¼å¼: timestamp - name - level - [file:line] - message
                        parts = line.split(" - ")
                        if len(parts) >= 5:
                            log_entry = {
                                "timestamp": parts[0],
                                "name": parts[1],
                                "level": parts[2].strip(),
                                "message": " - ".join(parts[4:]),  # æ¶ˆæ¯å¯èƒ½åŒ…å« ' - '
                            }
                        elif len(parts) >= 3:
                            # ç®€åŒ–æ ¼å¼: timestamp - name - level - message
                            log_entry = {
                                "timestamp": parts[0],
                                "name": parts[1] if len(parts) > 1 else "",
                                "level": parts[2].strip() if len(parts) > 2 else "INFO",
                                "message": " - ".join(parts[3:]) if len(parts) > 3 else line,
                            }
                        else:
                            log_entry = {
                                "timestamp": datetime.now().isoformat(),
                                "level": "INFO",
                                "message": line,
                            }

                    # è¿‡æ»¤æ—¥å¿—çº§åˆ«
                    if level and log_entry.get("level") != level.upper():
                        continue

                    # æœç´¢å…³é”®è¯
                    if search and search.lower() not in log_entry.get("message", "").lower():
                        continue

                    logs.append(log_entry)
        except Exception as e:
            logger.error(f"Failed to read log file {log_file}: {e}")

    # æŒ‰æ—¶é—´å€’åºæ’åº
    logs.sort(key=lambda x: x.get("timestamp", ""), reverse=True)

    # åˆ†é¡µ
    total = len(logs)
    logs = logs[offset : offset + limit]

    return {"logs": logs, "total": total, "offset": offset, "limit": limit}


@router.get("/logs/task/{task_id}", tags=["ğŸ” æ—¥å¿—ç®¡ç†"])
async def get_task_logs(task_id: str):
    """
    è·å–ç‰¹å®šä»»åŠ¡çš„å·¥ç¨‹åŒ–æ—¥å¿—ï¼ˆJSONLæ ¼å¼ï¼‰

    è¿”å›è¯¥ä»»åŠ¡çš„æ‰€æœ‰æ­¥éª¤æ—¥å¿—å’Œå…ƒæ•°æ®
    """
    from phone_agent.logging import TaskLogger

    task_logger = TaskLogger(log_dir="logs")

    try:
        logs = task_logger.read_logs(task_id)

        return {"logs": logs, "task_id": task_id, "total": len(logs)}
    except Exception as e:
        logger.error(f"Failed to read task logs: {e}")
        raise HTTPException(500, f"Failed to read logs: {str(e)}")


@router.delete("/logs", tags=["ğŸ” æ—¥å¿—ç®¡ç†"])
async def clear_logs():
    """æ¸…ç©ºæ‰€æœ‰æ—¥å¿—æ–‡ä»¶"""
    import os
    import shutil

    log_dir = "logs"

    if not os.path.exists(log_dir):
        return {"message": "No logs to clear"}

    try:
        # å¤‡ä»½æ—¥å¿—
        backup_dir = f"logs_backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        shutil.copytree(log_dir, backup_dir)

        # æ¸…ç©ºæ—¥å¿—ç›®å½•
        for file in os.listdir(log_dir):
            file_path = os.path.join(log_dir, file)
            if os.path.isfile(file_path):
                os.remove(file_path)

        return {"message": "Logs cleared successfully", "backup_location": backup_dir}
    except Exception as e:
        logger.error(f"Failed to clear logs: {e}")
        raise HTTPException(500, f"Failed to clear logs: {str(e)}")
